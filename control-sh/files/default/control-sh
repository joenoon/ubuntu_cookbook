#!/bin/sh

# control-sh
# easy start/stop/restart/signal creation
#
# Copyright 2010 Joe Noon (joe[at]stat.im) (http://stat.im)
#
# place this file at /usr/local/lib/control-sh
#
# example, somescript.sh:
#
# ==============================
# #!/bin/sh
# 
# RAILS_ROOT=`pwd`
# STDOUT_FILE="$RAILS_ROOT/log/resque-pool.out.log"
# STDERR_FILE="$RAILS_ROOT/log/resque-pool.err.log"
# lockfile="$RAILS_ROOT/tmp/pids/resque-pool.pid"
# 
# runcmd() {
#   nohup env rake resque:pool >> "$STDOUT_FILE" 2>> "$STDERR_FILE" < /dev/null &
# }
# 
# details() {
#   echo -n "Current pool: "
#   if [ -e "$lockfile" ]; then
#     echo `cat $lockfile`
#   else
#     echo "no pid"
#   fi
#   ps -ef f | grep [r]esque | grep -v $$
# }
# . /usr/local/lib/control-sh
# ==============================
#
# required vars: 
#   lockfile   (e.g. /tmp/myapp.pid)
# optional vars:
#   stop_sig   (e.g. TERM (default), INT, QUIT, KILL, etc)
# required functions:
#   runcmd     (should background the process using nohup, lockfile will be updated with PID automatically)
# optional functions:
#   details    (any output you want to show for this process)
#
# restart will start the process if not already running

set -e

waitonlive() {
  if [ -n "$1" ]; then
    echo -n "waiting for $1 to live..."
    until (kill -0 "$1" > /dev/null 2>&1); do
      sleep 1
    done
    echo "done."
  fi
}

waitonkill() {
  if [ -n "$1" ]; then
    echo -n "waiting for $1 to die..."
    while (kill -0 "$1" > /dev/null 2>&1); do
      sleep 1
    done
    echo "done."
  fi
}

sig() {
  if [ -n "$1" ]; then
    pid=`cat $lockfile`
    kill -$1 $pid
    echo "sent $1 to $pid"
  fi
}

usage() {
  echo "Usage: [start|stop|restart|status|details|sig]"
}

running() {
  if [ -e "$lockfile" ]; then
    pid=`cat $lockfile`
    if [ -n "$pid" ]; then
      if (kill -0 "$pid" > /dev/null 2>&1); then
        return 0
      fi
    fi
  fi
  return 1
}

stop() {
  if (running); then
    local pid=`cat $lockfile`
    if [ -n "$stop_sig" ]; then
      sig $stop_sig
    else
      sig "TERM"
    fi
    waitonkill $pid
  fi
  rm -f $lockfile
}

start() {
  if (running); then
    echo "running"
  else
    if (type runcmd | grep "function" > /dev/null 2>&1); then
      runcmd
      echo $! > $lockfile
      waitonlive `cat $lockfile`
    else
      echo "runcmd is not defined!"
    fi
  fi
}

case $1 in
  stop)
    stop
    ;;
  start)
    start
    ;;
  restart)
    stop
    start
    ;;
  details)
    if (type details | grep "function" > /dev/null 2>&1); then
      details
    fi
    ;;
  sig)
    if [ -n "$2" ]; then
      sig $2
    else
      echo "no signal given!"
    fi
    ;;
  status)
    if running; then
      echo "running"
    else
      echo "not running"
    fi
    ;;
  *)
    usage
    exit 1
    ;;
esac
